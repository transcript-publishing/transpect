<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<set xmlns="http://transpect.io/xml2tex" 
     xmlns:xml2tex="http://transpect.io/xml2tex" 
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
     xmlns:tr="http://transpect.io">
  
  <xsl:import href="http://transpect.io/xslt-util/functx/Sequences/Sorting-and-Grouping/sort.xsl"/>
  
  <xsl:param name="s9y1-path" as="xs:string?"/>
  <xsl:param name="s9y2" as="xs:string?"><!-- type type like mono/anth--></xsl:param>
  <xsl:param name="s9y2-path" as="xs:string?"/>
  <xsl:param name="s9y3" as="xs:string?"><!-- series type like std--></xsl:param>
  <xsl:param name="s9y3-path" as="xs:string?"/>
  
  <xsl:param name="s9y4-path" as="xs:string?"/>
  
  <xsl:param name="table-caption-pos" as="xs:string?"/>
  <xsl:param name="figure-caption-pos" as="xs:string?"/>
  <xsl:param name="sans-font"   as="xs:string?"/>
  
  <xsl:variable name="create-customer-toctitles" select="true()" as="xs:boolean"/>
  
  <xsl:variable name="is-collection" select="matches($basename,  'ts_[a-z]{3}_anth_')" as="xs:boolean"/>
  <xsl:variable name="is-journal" select="matches($basename,  'ts_jrn_[a-z]{3,4}_')" as="xs:boolean"/>
  <xsl:variable name="series-options" select="concat(',lay_type=', $s9y3)" as="xs:string">
    <!-- add series specific usepackage options. for example journal_series=zig or lay_type=std (https://redmine.le-tex.de/issues/14510#change-80305)-->
  </xsl:variable>

 <xsl:variable name="letter-spacing-def" select="''" as="xs:string?">
    <!-- https://mattermost.le-tex.de/letexml/pl/3bo8ggkcxfnnmqnkbi169usnby -->
  </xsl:variable>

  <!-- see the wiki link below for details
       https://redmine.le-tex.de/projects/transpect-typesetter/wiki/Titelei -->
  <xsl:variable name="metadata" as="element(dbk:keywordset)?" 
                select="/dbk:*/dbk:info/dbk:keywordset[@role eq 'titlepage']"/>
  <!-- person metadata -->
  <xsl:variable name="editors" as="element(dbk:keyword)*" 
                select="$metadata/dbk:keyword[@role eq 'Herausgeber']"/>
  <xsl:variable name="authors" as="element(dbk:keyword)*" 
                select="$metadata/dbk:keyword[@role eq 'Autor']"/>
  <xsl:variable name="author-info" as="element(dbk:keyword)*"
                select="$metadata/dbk:keyword[@role eq 'Autoreninformationen']" />
  <xsl:variable name="editor-info" as="element(dbk:keyword)*"
                select="$metadata/dbk:keyword[@role eq 'Herausgeberinformationen']" />
  <xsl:variable name="series-editors" as="element(dbk:keyword)*"
                select="$metadata/dbk:keyword[@role eq 'Reihenherausgeber'][normalize-space()]"/>
  <xsl:variable name="series-editor-info" as="element(dbk:keyword)*"
                select="$metadata/dbk:keyword[@role eq 'Reihenherausgeberinformationen'][normalize-space()]"/>
  <!-- title metadata -->
  <xsl:variable name="title" as="element(*)?"
                select="$metadata/dbk:keyword[@role eq 'Titel'][not(. = 'Fallback')]" />
  <xsl:variable name="title-for-running-head" as="element(*)?" 
                select="(/dbk:*/dbk:title,
                         /dbk:*/dbk:info/dbk:title,
                         $title)[1]"/>
  <xsl:variable name="subtitle" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Untertitel']"/>
  <xsl:variable name="shorttitle" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Kurztitel']"/>
  <xsl:variable name="additional-info1" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role = 'ZusatzinfosI']"/>
  <xsl:variable name="additional-info2" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ZusatzinfosII']"/>
  <xsl:variable name="additional-info3" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role = ('Zusatzinfos', 'ZusatzinfosIII')]"/>
  <xsl:variable name="additional-info4" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ZusatzinfosIV']"/>
  <!-- cover image -->
  <xsl:variable name="cover-href" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Cover']"/>
  <!-- series metadata -->
  <xsl:variable name="series-number" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihennummer']"/>
  <xsl:variable name="series-name"  as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihe']"/>
  <xsl:variable name="subseries-name"  as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihenuntertitel']"/>
  <xsl:variable name="volume" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Bandnummer']"/>
  <xsl:variable name="issue" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Ausgabe']"/>
  <!-- publisher -->
  <xsl:variable name="publisher-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsname']"/>
  <xsl:variable name="publisher-imprint-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsimprint']"/>
  <xsl:variable name="publisher-imprint-info" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsinfo']"/>
  <xsl:variable name="series-logo-href" as="xs:string?" 
                select="replace(
                                lower-case(replace($metadata/dbk:keyword[@role eq 'Reihenlogo'], '\\(.)', '$1')), 
                                '^.*/(.+?)$',
                                '$1')"/>
  <xsl:variable name="publisher-logo-href" as="xs:string?" 
                select="replace(
                                lower-case(replace(($metadata/dbk:keyword[@role eq 'Verlagslogo'], 'transcriptb_neu.pdf')[1], '\\(.)', '$1')), 
                                '^.*/(.+?)$',
                                '$1')"/>
  <xsl:variable name="publisher-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagshinweis']"/>
  <xsl:variable name="publisher-location" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsort']"/>
  <xsl:variable name="publisher-website" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role = ('transcript-Website', 'Website')]"/>
  <!-- publication meta -->
  <xsl:variable name="doi" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'DOI']"/>
  <xsl:variable name="print-isbn" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Print-ISBN']"/>
  <xsl:variable name="epdf-isbn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'PDF-ISBN']"/>
  <xsl:variable name="epub-isbn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ePUB-ISBN']"/>
  <xsl:variable name="isbn-text" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ISBN-Text']"/>
  <xsl:variable name="issn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ISSN']"/>
  <xsl:variable name="dedication" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Widmung']"/>
  <xsl:variable name="acknowledgements" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Dank']"/>
  <xsl:variable name="editorial" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Editorial']"/>
  <xsl:variable name="edition-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Edition-Note']"/>
  <xsl:variable name="pub-year" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Jahr']"/>
  <xsl:variable name="journal-title" as="xs:string?"
                select="$metadata/dbk:keyword[@role eq 'Zeitschriftentitel']"/>
  <xsl:variable name="statement" as="element(dbk:keyword)*"
                select="($metadata/dbk:keyword[@role eq 'Qualifikationsnachweis'], $metadata/dbk:keyword[@role eq 'Gutachter'])"/>
  <xsl:variable name="biblio-info" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Bibliografische_Information']"/>
  <xsl:variable name="print-note" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Druckhinweis']"/>
  <xsl:variable name="environmental-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Papier']"/>
  <!-- Contributor Meta -->
  <xsl:variable name="lectorate" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lektorat']"/>
  <xsl:variable name="translator" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Ubersetzer']"/>
  <xsl:variable name="typesetter" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Satz']"/>
  <xsl:variable name="printer" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Druck']"/>
  <xsl:variable name="used-font" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Schrift']"/>
  <xsl:variable name="cover-credit" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Umschlagcredit']"/>
  <xsl:variable name="cover-art" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Umschlaggestaltung']"/>
  <xsl:variable name="cover-concept" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Umschlagkonzept']"/>
  <xsl:variable name="copy-editing" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Korrektorat']"/>
  <xsl:variable name="converter" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Konvertierung']"/>
  <!-- Licencing meta, https://redmine.le-tex.de/issues/13870 -->
  <xsl:variable name="copyright-note" as="element()?"
                select="if ($metadata/dbk:keyword[@role eq 'Copyright'][dbk:para] 
                            and 
                            not($metadata/dbk:keyword[@role eq 'Lizenz'][contains(., 'BY')]))
                        then $metadata/dbk:keyword[@role eq 'Copyright']/*:para[1] 
                        else $metadata/dbk:keyword[@role eq 'Copyright']"/>
<!--    https://redmine.le-tex.de/issues/13098#change-72104-->
  <xsl:variable name="copyright-holder" as="element(dbk:para)*" 
                select="if ($metadata/dbk:keyword[@role eq 'Copyright'][count(dbk:para[normalize-space()]) gt 1] 
                            and 
                            not($metadata/dbk:keyword[@role eq 'Lizenz'][contains(., 'BY')])) 
                        then $metadata/dbk:keyword[@role eq 'Copyright']/dbk:para[not(position() = 1)]
                        else ()"/>
  <xsl:variable name="license-logo-href" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Lizenzlogo']"/>
  <xsl:variable name="license-text" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenztext']"/>
  <xsl:variable name="license-link" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenzlink']"/>
  <xsl:variable name="license-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenz']"/>
  <!-- funding statement -->
  <xsl:variable name="funder-name" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Fordername']"/>
  <xsl:variable name="funder-logo" as="xs:string*" 
                select="$metadata/dbk:keyword[@role eq 'Forderlogos']//text()"/>
  <xsl:variable name="funder-pretext" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Fordertext']"/>
  <xsl:variable name="funder-posttext" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Fordertextpost']"/>
  <xsl:variable name="bibl-issn" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'BiblISSN']"/>
  <xsl:variable name="bible-issn" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'BibleISSN']"/>
  <xsl:variable name="advertisement" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Werbung']"/>
  
  <xsl:variable name="create-customer-toctitles"  select="true()" as="xs:boolean"/>

  <xsl:variable name="scripts" as="element(script)*" xmlns="">
    <script name="arabic"   unicode-range="&#x600;-&#x6ff;&#x750;-&#x77f;"/>
    <script name="syriac"   unicode-range="&#x700;-&#x74f;"/>
    <script name="armenian" unicode-range="&#x530;-&#x58f;&#xfb13;-&#xfb17;"/>
    <script name="chinese"  unicode-range="&#12288;-&#12351;&#x3002;&#x4e00;-&#x9fff;"/>
    <script name="hebrew"   unicode-range="&#x590;-&#x5ff;&#xfb1d;-&#xfb4f;"/>
    <script name="japanese" unicode-range="&#x3040;-&#x309f;&#x30a0;-&#x30ff;&#12352;-&#12543;"/>
    <!--<script name="greek"    unicode-range="&#x370;-&#x3ff;&#7936;-&#8191;"/> overwritten temporarily for CI tests-->
  </xsl:variable>

  <ns prefix="dc" uri="http://purl.org/dc/elements/1.1/"/>
  <ns prefix="rdf" uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>
  
  <import href="../../common/xml2tex/latex.conf.xml"/>  
  
  <preamble>%
    % by transcript publishers
    %
    <xsl:value-of select="concat('\documentclass[',
                                 string-join(($babel-langs[position() ne 1],
                                            $babel-langs[1]), (: 1st lang is main lang and comes last :)
                                            ','),
                                 if($is-collection) then ',pubtype=collection' else if ($is-journal) then ',pubtype=journal' else (),
                                 if($notes-per-chapter = ('yes', 'true') or $notes-type = 'footnotes') then ',resetnotesperchapter' else (),
                                 if($notes-type eq 'endnotes' and $endnotes-with-chapter eq 'yes')  
                                                                     then ',endnoteswithchapters,endnotelinks'
                                 else if($notes-type eq 'endnotes') 
                                                                     then ',endnotes,endnotelinks' 
                                 else (),
                                 if($notes-type eq 'endnotes' and $notes-per-chapter-notoc eq 'yes') then ',ennotoc' else (),
                                 xml2tex:foreign-scripts(root()),
                                 ']{cocotex}&#xa;')"/>
    \usepackage{htmltabs}&#xa;
    \definecolor{color-1}{rgb}{0,0,0}
    \definecolor{color-2}{rgb}{0.85,0.85,0.85}
    <xsl:for-each select="xml2tex:rgb-to-tex-color( $colors )">
      <xsl:if test="not(matches(., 'color-(1|2)$'))">        
        <xsl:value-of select="concat('\define', ., '&#xa;')"/>
      </xsl:if>
    </xsl:for-each>
    <xsl:value-of select="concat('\usepackage[lay=',
                                 lower-case($layout),
                                 ',captions_figure=',
                                 if($figure-caption-pos eq 'bottom') then 'bottom' else 'top',
                                 ',captions_table=',
                                 if($table-caption-pos eq 'bottom') then 'bottom' else 'top',
                                 if($sans-font eq 'noto-condensed') then ',altFonts' else (),
                                 $series-options,
                                 ']{transcript}&#xa;')"/>
    
    <xsl:if test="$langs = 'zh'">
      <xsl:value-of select="'\usepackage{CJK}&#xa;'"/>
    </xsl:if>
    <xsl:text>&#xa;\begin{tpMeta}&#xa;</xsl:text>
    <!-- authors -->
    <xsl:for-each select="if(count($authors/*) gt 1) then $authors/* else $authors">
      <xsl:variable name="pos" select="position()" as="xs:integer"/>
      <xsl:text>&#xa;\begin{tpAuthor}</xsl:text>
      <xsl:value-of select="concat('&#xa;\tpFullName{', replace(., '[\p{Zs}&#xa;]', '~'), '}')"/>
      <xsl:if test="$author-info">
        <xsl:text>&#xa;\tpBio{</xsl:text>
        <xsl:apply-templates select="if(count($authors/*) gt 1) then $author-info/*[$pos] else $author-info" mode="#current"/>
        <xsl:text>}&#xa;</xsl:text>
      </xsl:if>
      <xsl:text>\end{tpAuthor}&#xa;</xsl:text>
    </xsl:for-each>
    <xsl:for-each select="if(count($editors/*) gt 1) then $editors/* else $editors">
      <xsl:variable name="pos" select="position()" as="xs:integer"/>
      <xsl:text>&#xa;\begin{tpEditor}</xsl:text>
      <xsl:value-of select="concat('&#xa;\tpFullName{', replace(., '[\p{Zs}&#xa;]', '~'), '}')"/>
      <xsl:value-of select="concat('&#xa;\tpBio{', 
                                                normalize-space(if(count($editors/*) gt 1) then xml2tex:meta-remove-links-etc($editor-info/*[$pos]) else xml2tex:meta-remove-links-etc($editor-info)), 
                                                '}&#xa;')"/>
      <xsl:text>\end{tpEditor}&#xa;</xsl:text>
    </xsl:for-each>
    <xsl:for-each select="if(count($series-editors/*) gt 1) then $series-editors/* else $series-editors">
      <xsl:variable name="pos" select="position()" as="xs:integer"/>
      <xsl:text>&#xa;\begin{tpSeriesEditor}</xsl:text>
      <xsl:value-of select="concat('&#xa;\tpFullName{', replace(normalize-space(.), '[\p{Zs}&#xa;]', '~'), '}')"/>
      <xsl:value-of select="concat('&#xa;\tpBio{', 
                                                normalize-space(if(count($series-editors/*) gt 1) then xml2tex:meta-remove-links-etc($series-editor-info/*[$pos]) else xml2tex:meta-remove-links-etc($series-editor-info)), 
                                                '}&#xa;')"/>
      <xsl:text>&#xa;\end{tpSeriesEditor}&#xa;</xsl:text>
    </xsl:for-each>
  <!-- for oop only → do not deploy in common -->
    <xsl:choose>
      <xsl:when test="$s9y2 = 'mono'">
        <!-- run titles, https://redmine.le-tex.de/issues/14963 / https://github.com/transcript-publishing/mapping-conventions/blob/main/column-title/index.md  -->
        <xsl:value-of select="'&#xa;\tpRunTitle{'"/>
        <!--  Autor, Doppelpunkt, LZ, Titel. Wenn eines oder beide leer sind: kein Doppelpunkt/LZ
        erste Quelle: hub/info/title (vormals ts_meta_book_title) und keyword[@role = 'Run_Autor'] vormals ts_meta_headline_author
        wenn nicht in docx, aus klopotek.xml/meta.xml (Autor/Titel). mehreren Autor:innen durch Komma trennen-->
        <xsl:choose>
          <xsl:when test="/dbk:*/dbk:info/dbk:title or /dbk:*/dbk:info/dbk:keywordset[@role = 'titlepage']/dbk:keyword[@role = 'Run_Autor']">
            <xsl:sequence select="string-join(
                                        (xml2tex:meta-remove-links-etc(/dbk:*/dbk:info/dbk:keywordset[@role = 'titlepage']/dbk:keyword[@role = 'Run_Autor'])[normalize-space()], 
                                         xml2tex:meta-remove-links-etc(/dbk:*/dbk:info/dbk:title)[normalize-space()]
                                        ), 
                                        ': ')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="string-join(
              (string-join(/dbk:*/dbk:info/dbk:keywordset[@role = 'titlepage']/dbk:keyword[@role = 'Autor']/node()[normalize-space()], ', '),
              /dbk:*/dbk:info/dbk:keywordset[@role = 'titlepage']/dbk:keyword[@role = 'Titel'][normalize-space()]),
              ': ')"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="'}'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="xml2tex:meta2tex($title-for-running-head, (), 'tpRunTitle')"/>
      </xsl:otherwise> 
    </xsl:choose>
    <xsl:sequence select="
      xml2tex:meta2tex(($title, $title-for-running-head)[1], (), 'tpTitle'),
      xml2tex:meta2tex($subtitle, (), 'tpSubtitle'),
      xml2tex:meta2tex($shorttitle, (), 'tpShortTitle'),
      xml2tex:meta2tex($series-number, (), 'tpNumber'),
      xml2tex:meta2tex($series-name, (), 'tpSeries'),
      xml2tex:meta2tex($subseries-name, (), 'tpSubSeries'),
      xml2tex:meta2tex($volume, (), 'tpVolume'),
      xml2tex:meta2tex($issue, (), 'tpIssue'),
      xml2tex:meta2tex($publisher-name, (), 'tpPublisher'),
      xml2tex:meta2tex($publisher-imprint-name, (), 'tpPubDivision'),
      xml2tex:meta2tex($publisher-imprint-info, (), 'tpPubDivInfo'),
      xml2tex:meta2tex($publisher-note, (), 'tpPubNote'),
      xml2tex:meta2tex($publisher-location, (), 'tpPubPlace'),
      xml2tex:meta2tex($print-isbn, (), 'tpISBN'),
      xml2tex:meta2tex($epdf-isbn, (), 'tpEISBN'),
      xml2tex:meta2tex($epub-isbn, (), 'tpEpubISBN'),
      xml2tex:meta2tex($isbn-text, (), 'tpEpubPreText'),
      xml2tex:meta2tex($issn, (), 'tpISSN'),
      xml2tex:meta2tex($biblio-info/*:para[1], (), 'tpBiblioTitle'),
      xml2tex:meta2tex($biblio-info/*:para[not(position() = 1)], (), 'tpBiblio'), 
      xml2tex:meta2tex($print-note, (), 'tpPrintNote'),
      xml2tex:meta2tex($environmental-note, (), 'tpEnvDisclaimer'),
      xml2tex:meta2tex($acknowledgements, (), 'tpAcknowledgements'),
      xml2tex:meta2tex($dedication, (), 'tpDedication'),
      xml2tex:meta2tex($editorial, (), 'tpEditorial'),
      xml2tex:meta2tex($edition-note, (), 'tpEditionNote'),
      xml2tex:meta2tex($additional-info1, (), 'tpAddNoteI'),
      xml2tex:meta2tex($additional-info2, (), 'tpAddNoteII'),
      xml2tex:meta2tex($additional-info3, (), 'tpAddNoteIII'),
      xml2tex:meta2tex($additional-info4, (), 'tpAddNoteIV'),
      xml2tex:meta2tex($publisher-website, (), 'tpPubWeb'),
      xml2tex:meta2tex($doi, (), 'tpDOI'),
      xml2tex:meta2tex($pub-year, (), 'tpYear'),
      xml2tex:meta2tex($journal-title, (), 'tpJournalName'),
      xml2tex:meta2tex($lectorate, (), 'tpLectorate'),
      xml2tex:meta2tex($translator, (), 'tpTranslator'),
      xml2tex:meta2tex($copy-editing, (), 'tpQA'),
      xml2tex:meta2tex($cover-credit, (), 'tpCoverDesign'),
      xml2tex:meta2tex($cover-art, (), 'tpCoverImage'),
      xml2tex:meta2tex($cover-concept, (), 'tpCoverConcept'),
      xml2tex:meta2tex($typesetter, (), 'tpTypesetter'),
      xml2tex:meta2tex($printer, (), 'tpPrint'),
      xml2tex:meta2tex($used-font, (), 'tpUsedFont'),
      xml2tex:meta2tex($converter, (), 'tpConversion'),
      xml2tex:meta2tex($license-link, (), 'tpLicenceLink'),
      xml2tex:meta2tex($license-name, (), 'tpLicenceName'),
      xml2tex:meta2tex($funder-pretext, (), 'tpFundingPreText'),
      xml2tex:meta2tex($funder-posttext, (), 'tpFundingPostText'),
      xml2tex:meta2tex($bibl-issn, (), 'tpBiblISSN'),
      xml2tex:meta2tex($bible-issn, (), 'tpBibleISSN')
      "/>
    <!-- logos image -->
    <xsl:if test="normalize-space($cover-href)">
      <xsl:value-of select="concat('&#xa;\tpCover{cover/', $cover-href, '}&#xa;')"/>
    </xsl:if>
    <xsl:if test="matches(string-join($statement, ''), '\S')">
      <xsl:text>&#xa;\tpStatement{</xsl:text>
       <xsl:for-each select="$statement[normalize-space()]">
        <xsl:apply-templates select="."  mode="strip-meta"/>
      </xsl:for-each>
      <xsl:text>}&#xa;</xsl:text>
    </xsl:if>
    <xsl:if test="normalize-space($series-logo-href)">
      <xsl:value-of select="concat('&#xa;\tpSeries{\includegraphics{logos/series/', $series-logo-href, '}}&#xa;')"/>
    </xsl:if>
    <xsl:if test="normalize-space($publisher-logo-href)">
      <xsl:value-of select="concat('&#xa;\tpPubLogo{logos/', $publisher-logo-href, '}&#xa;')"/>
    </xsl:if>
    <!-- licensing meta, https://redmine.le-tex.de/issues/13870. cannot use xml2tex:meta2tex() here because several paras might occur  -->
    <xsl:if test="normalize-space($copyright-note)">
<!--      <xsl:text>&#xa;\tpCopyright{</xsl:text>
      <xsl:for-each select="$copyright-note">
        <xsl:apply-templates select="." mode="strip-meta"/>
      </xsl:for-each>
      <xsl:text>}&#xa;</xsl:text>-->
      <xsl:sequence select="xml2tex:meta2tex($copyright-note, (), 'tpCopyright')"/>
    </xsl:if>
    <xsl:if test="$copyright-holder[normalize-space()]">
  <xsl:sequence select="xml2tex:meta2tex($copyright-holder, (), 'tpCopyrightDisclaimer')"/>
<!--      <xsl:text>&#xa;\tpCopyrightDisclaimer{</xsl:text>
      <xsl:for-each select="$copyright-holder">
        <xsl:apply-templates select="." mode="strip-meta"/>
      </xsl:for-each>
      <xsl:text>}&#xa;</xsl:text>-->
    </xsl:if>
    <xsl:if test="normalize-space($license-logo-href)">
      <xsl:value-of select="concat('&#xa;\tpLicenceLogo{logos/cc/', 
                                   replace(
                                           replace($license-logo-href, '\\(.)', '$1'),
                                           '^.*/(.+?)$',
                                           '$1'),
                                   '}&#xa;')"/>
    </xsl:if>
    <xsl:if test="normalize-space($license-text)">
      <xsl:value-of select="concat('&#xA;\tpLicenceText{', 
                                   string-join($license-text/*, '\\&#xa;'),
                                   '}&#xA;')"/>
    </xsl:if>
    <xsl:if test="normalize-space($funder-name) or exists($funder-logo)">
      <xsl:for-each select="$funder-logo[normalize-space()]">
        <xsl:text>&#xa;\begin{tpFunding}</xsl:text>
        <!-- currently no method for multiple funding logo/name pairs -->
        <xsl:if test="normalize-space($funder-name) and position() eq 1">
          <xsl:value-of select="concat('&#xa;\tpFundName{', $funder-name, '}')"/>
        </xsl:if>
        <xsl:value-of select="concat('&#xa;\tpFundLogo{images/', 
                                      replace(normalize-space(.), '^(.+/)', ''), 
                                     '}')"/>
        <xsl:text>&#xa;\end{tpFunding}&#xa;</xsl:text>
      </xsl:for-each>  
    </xsl:if>
    <!-- journal-specific metadata -->
    <xsl:call-template name="xml2tex:add-publicationtype-specific-meta"/>
    <xsl:text>&#xa;\end{tpMeta}&#xa;</xsl:text>
    <xsl:for-each select="//dbk:index">
      <xsl:variable name="index-index" as="attribute(remap)" select="@remap"/>
      <xsl:value-of select="concat('\newindex{', $index-index, '}{', $index-index, '_idx}{', $index-index, '_ind}{', normalize-space(dbk:info/dbk:title), '}&#xa;')"/>
    </xsl:for-each>
    <xsl:if test="$toc-depth">
      <!-- chapter 0 ist und section 1, part (normalerweise) -1, subsection 2 -->
      <xsl:value-of select="concat('\setcounter{tocdepth}{', 
                                   if(//dbk:part) 
                                   then xs:string(xs:integer($toc-depth) - 2)
                                   else xs:string(xs:integer($toc-depth) - 1),
                                   '}&#xa;')"/>
    </xsl:if>

    <!-- no numbering: -99, -9 would be sufficient -->
    <xsl:if test="$numbering-depth">
      <xsl:value-of select="concat('\setcounter{secnumdepth}{',
                                   $secnumdepth,
                                   '}&#xa;')"/>
    </xsl:if>
  </preamble>

  <front>
    <xsl:if test="$title-pages eq 'yes'">
      <xsl:text>\tpMaketitle&#xa;</xsl:text>  
    </xsl:if>
    <xsl:apply-templates select="/dbk:*/dbk:colophon[@role = 'dedication']
                                 |/dbk:*/dbk:dedication" mode="#current">
      <xsl:with-param name="keep" select="true()" tunnel="yes"/>
    </xsl:apply-templates>
    <xsl:text>\tableofcontents&#xa;</xsl:text>
  </front>
  
  
  <xsl:template name="xml2tex:add-publicationtype-specific-meta">
    <!-- placeholder-->
  </xsl:template>

  <template context="dbk:para[matches(@role, $endnotes-heading-style)]">
    <xsl:value-of select="concat('&#xa;\def\notesname{', . ,'}')"/>
    <xsl:text>&#xa;\printnotes&#xa;</xsl:text>
  </template>
   
    <!-- suppress additional underline markup in titles -->
  
  <template context="dbk:part/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:chapter/dbk:info/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:section/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:bibliography/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]">
    <rule>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:bibliography[not(@role eq 'Citavi')]/dbk:bibliodiv">
    <xsl:variable name="level" select="count(ancestor::dbk:bibliography)" as="xs:integer"/>
    <xsl:variable name="name" as="xs:string"
                  select="if($level eq 1) then 'section'
                     else if($level eq 2) then 'subsection'
                     else if($level eq 3) then 'subsubsection'
                     else                      'paragraph'"/>
    <xsl:value-of select="concat('\def\bibname{', dbk:title, '}&#xa;', 
                                 '\renewcommand\bibsection{\', $name, '*{\bibname}}&#xa;')"/>
    <rule name="bibsection" type="env">
      <text/>
    </rule>
  </template>



  <xsl:variable name="dialogue-style" select="'^[a-z]+dialogue'" as="xs:string"/>

  <template context="dbk:blockquote[dbk:para][not(matches(@role, concat('^[a-z]+_?verse.*$', '|', $dialogue-style)))]">
    <rule name="quotation" type="env">
      <text/>
    </rule>
  </template>
  
  <template context="dbk:blockquote[matches(@role, $verse-misc-style)]/dbk:para">
    <!-- add \tpBreak after every verse para. perhaps it might be better for future projcts 
      to work with linebreaks and para if an empty line is desired-->
    <rule break-after="1">
      <text/>
      <xsl:if test="not(. is ../dbk:para[last()])"><text>\tpBreak</text></xsl:if>
    </rule>
  </template>
  
<!--  <template context="dbk:blockquote[not(matches(@role, '^[a-z]+_?verse.*$'))]
                                   [count(dbk:para) gt 1]/dbk:para">
    <rule break-after="2">
      <text>\setlength{\parindent}{5mm}</text>
      <text/>
    </rule>
  </template>-->
  
<!-- <template context="dbk:para[following-sibling::*[1][self::dbk:blockquote]]
                   |dbk:blockquote/dbk:para[last()]
                   |dbk:caption/dbk:para[last()]">
    <!-\- this prevents processing on para’s attributes. testing results if commented out. -\->
    <rule break-after="0">
      <text/>
    </rule>
    <!-\- copied from common to reinstall template priorities-\->
  </template>-->

  <template context="dbk:para[dbk:personname[@role eq 'speaker']]">
    <rule name="item" type="cmd" break-before="1">
      <option select="dbk:personname[@role eq 'speaker']/normalize-space(string-join(node(), ''))"/>
      <text select="node() except dbk:personname[@role eq 'speaker']"/>
    </rule>
  </template>
  
  <template context="dbk:blockquote[matches(@role,'tsdialogue')]/dbk:para[not(dbk:personname)]">
    <!--https://redmine.le-tex.de/issues/15597-->
    <rule name="infoItem" type="cmd" break-before="1">
      <param select="node()"/>
    </rule>
  </template>

  <!-- https://redmine.le-tex.de/issues/9852 -->
  
  <xsl:variable name="list-mark-map" as="element(xml2tex:map)+">
    <xml2tex:map from="dash"   to="&#x2014;"/>
    <xml2tex:map from="bullet" to="&#x2022;"/>
    <xml2tex:map from="circle" to="&#x25cb;"/>
    <xml2tex:map from="square" to="&#x25aa;"/>
  </xsl:variable>

  <template context="dbk:itemizedlist[@mark]/dbk:listitem">
    <rule name="item" type="cmd">
      <option select="if(matches(parent::*/@mark, string-join($list-mark-map/@from, '|')))
                      then for $mark in parent::*/@mark
                           return $list-mark-map[@from eq $mark]/@to
                      else replace(parent::*/@mark, '⚬', '\$\\circ\$')"/>
      <text select="' '"/>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:para[matches(@role, 'tsmedia(caption|url|source)')]" priority="300"/>
  
  <template context="dbk:link[@xlink:href][matches(@xlink:href, '^(https?|ftp):') or matches(., '^(https?|ftp):')]">
    <rule name="href" type="cmd">
      <param select="replace(xml2tex:optionally-encode-uri((@url, @xlink:href)[1]), '(%|#|_|\\)', '\\$1' )"/>
      <param select="xml2tex:add-tactical-breaks-by-string-length(xml2tex:add-tactical-break-chars-in-linktext(.))"/>
    </rule>
  </template>
   
  <template context="dbk:title[matches(@role, $general-heading-style)]/dbk:tab[preceding-sibling::dbk:phrase[@role eq 'hub:identifier']]"/>

  <xsl:variable name="col-author-style" select="'^[a-z]{1,3}headline(author)$'" as="xs:string"/>

  <template name="col-titles">
    <!-- use col-style para for runtitle. if it doesn't exist and heading contains footnotes or linebreaks:
         discard those and use as column title. otherwise do not create an element-->

<!--    <xsl:choose>
      <xsl:when test="$is-collection">-->
<!--        links: tpAuthor/tpRunAuthorNameList, wenn es den nicht gibt: \tp(Run)Title | Rechts: \tp(Run)Title-->

        <xsl:if test="dbk:titleabbrev[matches(@role, $col-author-style)] or 
                      (dbk:author|dbk:authorgroup/dbk:author)[descendant::*[self::dbk:footnote | self::dbk:br]]">
          <rule name="tpRunAuthorNameList" type="cmd" break-before="1">
            <param select="(dbk:titleabbrev[matches(@role, $col-author-style)], 
                           (dbk:author|dbk:authorgroup/dbk:author)[descendant::*[self::dbk:footnote | self::dbk:br]]/dbk:personname/dbk:othername
                           )[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="remove-indexterm" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="run-override" select="true()" as="xs:boolean" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="dbk:titleabbrev[matches(@role, $col-head-style)] 
                      or  
                      dbk:title[descendant::*[self::dbk:footnote | self::dbk:br]]">
          <rule name="tpRunTitle" type="cmd" break-before="1">
            <param select="(dbk:titleabbrev[matches(@role, $col-head-style)] , dbk:title)[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="remove-indexterm" select="true()" as="xs:boolean" tunnel="yes"/>
              <with-param name="run-override" select="true()" as="xs:boolean" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="(dbk:title[descendant::*[self::dbk:footnote]]/dbk:phrase[@role = ('identifier', 'hub:identifier')] and not(dbk:titleabbrev[matches(@role, $col-head-style)]))
                      or 
                      dbk:titleabbrev[matches(@role, $col-head-style)]">
          <rule name="tpRunNumber" type="cmd" break-before="1">
            <param select="if (dbk:titleabbrev[matches(@role, $col-head-style)])
                           then dbk:titleabbrev[matches(@role, $col-head-style)]/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()
                           else dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="run-override" select="true()" as="xs:boolean" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>

    <xsl:if test="dbk:subtitle[descendant::*[self::dbk:footnote | self::dbk:br]]">
      <rule name="tpRunSubtitle" type="cmd" break-before="1">
        <param select="dbk:subtitle/node()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="run-override" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
  </template>
  
  <xsl:template match="*[self::dbk:title|dbk:subtitle|dbk:author]//text()[matches(., '[&#x1e24;&#x1e25;&#x1e6f;&#x1e0d;&#x1e2a;&amp;&#x9;&#xa0;&#x2000;-&#x200a;]+')]" 
                mode="xml2tex" priority="100000">
    <xsl:param name="toc-override" as="xs:boolean?" tunnel="yes"/>
    <xsl:param name="bm-override" as="xs:boolean?" tunnel="yes"/>
    <xsl:param name="run-override" as="xs:boolean?" tunnel="yes"/>
    <xsl:variable name="style" as="attribute()*" 
                  select="parent::*/(@css:font-weight, @css:font-style)"/>
    <xsl:analyze-string select="." regex="([&#x1e24;&#x1e25;&#x1e6f;&#x1e0d;&#x1e2a;]+)|([&amp;&#x9;&#xa0;&#x2000;-&#x200a;]+)">
      <xsl:matching-substring>
          <xsl:if test="regex-group(1)[normalize-space()]">
            <xsl:if test="not($toc-override eq true()) and not($bm-override eq true()) and not($run-override eq true())"><xsl:text>\textsffallback{</xsl:text></xsl:if>
            <xsl:value-of select="regex-group(1)"/>
            <xsl:if test="not($toc-override eq true()) and not($bm-override eq true()) and not($run-override eq true())"><xsl:text>}</xsl:text></xsl:if>
          </xsl:if>
          <xsl:if test="exists(regex-group(2))">
            <xsl:value-of select="if ($toc-override eq true() or $bm-override eq true() or $run-override eq true()) 
                                  then 
                                       replace(
                                         replace(
                                          translate(regex-group(2), '&#xa0;', '~'),
                                            '\\(&amp;)',
                                            '\\string$1'
                                            ),
                                            '\p{Zs}+',
                                         '&#x20;'
                                         ) 
                                      else regex-group(2)"/>
          </xsl:if>
      </xsl:matching-substring>
      <xsl:non-matching-substring>
        <xsl:value-of select="."/>
      </xsl:non-matching-substring>
    </xsl:analyze-string>
  </xsl:template>
  
  <!-- override toc-templates to allow newlines -->
  
  <template name="customer-toctitles">
    <rule name="tpTocTitle" type="cmd" break-after="0" break-before="1">
      <param select="dbk:title/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
        <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
        <with-param name="toc-override" select="true()" as="xs:boolean" tunnel="yes"/>
      </param>
    </rule>
    <xsl:if test="dbk:title[dbk:phrase[@role = ('identifier', 'hub:identifier')]]">
      <rule name="tpTocNumber" type="cmd" break-after="0" break-before="1">
        <param select="dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')]/text()">
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="toc-override" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="dbk:subtitle">
      <rule name="tpTocSubtitle" type="cmd" break-after="0" break-before="1">
        <param select="dbk:subtitle/node()">
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="toc-override" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="dbk:author or dbk:authorgroup/dbk:author">
      <rule name="tpTocAuthorNameList" type="cmd" break-after="0" break-before="1">
        <param select="(dbk:author|dbk:authorgroup/dbk:author)/dbk:personname/dbk:othername/node()">
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="toc-override" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
  </template>

  <!-- override of common function to allow section jumps -->
  
  <xsl:function name="tr:heading-level" as="xs:string?">
    <xsl:param    name="heading" as="element()"/>
    <xsl:variable name="style"   as="attribute(role)?" select="$heading/dbk:info/dbk:title[1]/@role"/>
    <xsl:choose>
      <xsl:when test="$style = 'tsheadingpart'">
        <xsl:sequence select="'part'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading1review', 'tsheading1reviewtoc')">
        <xsl:sequence select="'review'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading1', 'tsheading1nonum',  'tsheading1notoc', 'tsbackmatter1')">
        <xsl:sequence select="if ($is-collection or $is-journal) then 'contribution' else 'chapter'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading2', 'tsheading2nonum',  'tsheading2notoc', 'tsbackmatter2')">
        <xsl:sequence select="'section'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading3',  'tsheading3nonum',  'tsheading3notoc', 'tsbackmatter3')">
        <xsl:sequence select="'subsection'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading4', 'tsheading4nonum',  'tsheading4notoc',  'tsbackmatter4')">
        <xsl:sequence select="'subsubsection'"/>
      </xsl:when>
      <xsl:when test="$style = ('tsheading5', 'tsheading5nonum',  'tsheading5notoc', 'tsbackmatter5')">
        <xsl:sequence select="'paragraph'"/>
      </xsl:when>
     <xsl:when test="$style = 'tsheadheadword'">
        <xsl:sequence select="'subparagraph'"/>
      </xsl:when>
      <xsl:when test="($heading/local-name() = 'chapter' and $heading[@renderas = 'subhead'])
                       or
                      ($heading/local-name() = 'part' and $heading[@renderas = 'subhead'])">
        <!-- subparts from chapters or parts -->
        <xsl:sequence select="'subpart'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = 'part'
        or
        ($heading/local-name() = 'bibliography' and $heading/parent::dbk:*[local-name() = ('hub', 'book')][dbk:part])">
        <xsl:sequence select="'part'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('chapter', 'index') 
                      or 
                      ($heading/local-name() = 'section' and $heading[@renderas = 'chapter'])
                      or
                      ($heading/local-name() = 'bibliography' 
                      and (
                           $heading/parent::dbk:part 
                           or 
                           $heading/parent::dbk:*[local-name() = ('hub', 'book')][not(dbk:part)]
                          )
                      )">
        <!-- if subpart level exists chapters may be disguised as sections. For collections 
             level is called contribution and allows integration of abstracts and keywords -->
        <xsl:sequence select="if ($pubtype = ('collection', 'anth', '') 
                                              or contains($basename, '_anth_')
                                              or $heading[dbk:info[dbk:abstract or dbk:keywordset]]
                                              or $is-collection 
                                              or $is-journal) 
                              then 'contribution' 
                              else 'chapter'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('section', 'bibliography') and not($heading/ancestor::*:section)">
        <xsl:sequence select="'section'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('section', 'bibliography') and count($heading/ancestor::*:section) eq 1">
        <xsl:sequence select="'subsection'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('section', 'bibliography') and count($heading/ancestor::*:section) eq 2">
        <xsl:sequence select="'subsubsection'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('section', 'bibliography') and count($heading/ancestor::*:section) gt 2">
        <xsl:sequence select="'paragraph'"/>
      </xsl:when>
      <xsl:when test="$heading/local-name() = ('bibliodiv')">
        <xsl:variable name="level" select="count($heading/ancestor::dbk:bibliography)" as="xs:integer"/>
        <xsl:sequence select="     if($level eq 1) then 'section'
                              else if($level eq 2) then 'subsection'
                              else if($level eq 3) then 'subsubsection'
                              else                      'paragraph'"/>
      </xsl:when>
    </xsl:choose>
  </xsl:function>

  <xsl:function name="tr:determine-fig-class" as="xs:string?">
    <xsl:param name="elt" as="element(*)"/>
    <xsl:sequence select="if (matches($elt/@role, '^figure-[a-z]$'))
                          then concat('class=', upper-case(replace($elt/@role, '^figure-', '')))
                          else ()"/>
  </xsl:function>

  <template context="dbk:bridgehead">
    <rule name="heading" type="env" break-after="2" break-before="1">
      <option select="'notoc,noBM'"/>
      <param select="'subparagraph'"/>
      <xsl:text>&#xa;\tpTitle{</xsl:text>
      <xsl:apply-templates select="node()" mode="#current"/>
      <xsl:text>}</xsl:text>
      <xsl:if test="descendant::*[self::dbk:footnote | self::dbk:br | self::dbk:indexterm]">
        <rule name="tpRunTitle" type="cmd" break-before="1">
          <param select="node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
            <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
            <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
          </param>
        </rule>
      </xsl:if>
    </rule>
  </template>

  <xsl:template match="dbk:keywordset[@role='titlepage']/dbk:keyword
                          [not(@role = ('Herausgeber', 'Autor', 'Herausgeberinformationen', 'Bibliografische_Information', 'Copyright'))]/dbk:para[not(position() eq last())] |
                       dbk:keywordset[@role='titlepage']/dbk:keyword
                          [@role = ('Copyright')]/dbk:para[not(position() eq last())][not(position() eq 1) or $license-name[contains(., 'BY')]]" mode="strip-meta" priority="4">
    <xsl:apply-templates mode="#current"/>
    <!-- https://redmine.le-tex.de/issues/13334#note-5-->
    <xsl:text>\par </xsl:text>
  </xsl:template>


  <xsl:template match="dbk:keywordset[@role='titlepage']
                                     [dbk:keyword[@role = ('Qualifikationsnachweis')][normalize-space()]]/dbk:keyword
                                     [@role = ('Gutachter')][normalize-space()]" mode="strip-meta" priority="4">
    <xsl:text>\par </xsl:text>   
    <xsl:apply-templates mode="#current"/>
    <!-- https://redmine.le-tex.de/issues/13508-->

  </xsl:template>

  <xsl:template match="text()[ancestor::*[self::dbk:keyword[matches(., 'file:|http|www|(\.(png|PNG|jpe?g|pdf|JPE?G|PDF|eps|EPS)\p{Zs}*$)')] ]]" mode="escape-bad-chars" priority="300">
    <!-- prevent filename replacement in keywords -->
    <xsl:choose>
      <xsl:when test="matches(., 'file:|\.(png|PNG|jpe?g|pdf|JPE?G|PDF|eps|EPS)\p{Zs}*$') and not(ancestor::*[self::dbk:link])">
        <xsl:value-of select="."/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="content" select="xml2tex:escape-for-tex(replace( ., '\\', '\\textbackslash ' ))" as="xs:string"/>
        <xsl:value-of select="$content"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:function name="xml2tex:generate-clear-after-p" as="xs:string?">
    <xsl:param name="context" as="element()"/>
    <xsl:choose>
      <xsl:when test="$context[tr:determine-float-pos(.) = 'orientation=landscape']
                              [not(replace(@xml:id, '-\d+$', '') = replace($context/following-sibling::*[1]/@xml:id, '-\d+$', ''))(:avoid barriers between slitted tables:)]">
        <xsl:text>\FloatBarrier&#xa;</xsl:text>
        <!--  https://redmine.le-tex.de/issues/15527, 
              https://redmine.le-tex.de/issues/15565 -->
      </xsl:when>
      <xsl:when test="$context[matches(tr:determine-float-pos(.), 'float-pos=t?p') 
                              and not(following-sibling::*[1][xml2tex:is-float-object(.)])
                              and (not(preceding-sibling::*[1][xml2tex:is-float-object(.)])
                             or
                                (preceding-sibling::*[1][matches(tr:determine-float-pos(.), 'float-pos=t?p')]
                                and not(preceding-sibling::*[2][xml2tex:is-float-object(.)])
                                ))
                                ]">
        <xsl:text>\tpFloatBarrier&#xa;</xsl:text>
        <!--  https://redmine.le-tex.de/issues/11889#note-18: after last float-pos=p, https://redmine.le-tex.de/issues/15527 -->
      </xsl:when>
    </xsl:choose>
  </xsl:function>

</set>
