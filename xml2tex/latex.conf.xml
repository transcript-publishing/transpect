<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<set xmlns="http://transpect.io/xml2tex" 
     xmlns:xml2tex="http://transpect.io/xml2tex" 
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  
  <xsl:import href="http://transpect.io/xslt-util/functx/Sequences/Sorting-and-Grouping/sort.xsl"/>
  
  <xsl:variable name="is-collection" select="matches($basename,  'ts_[a-z]{3}_anth_')" as="xs:boolean"/>

  <!-- see the wiki link below for details
       https://redmine.le-tex.de/projects/transpect-typesetter/wiki/Titelei -->
  <xsl:variable name="metadata" as="element(dbk:keywordset)?" 
                select="/dbk:*/dbk:info/dbk:keywordset[@role eq 'titlepage']"/>
  <!-- person metadata -->
  <xsl:variable name="editors" as="element(dbk:keyword)*" 
                select="$metadata/dbk:keyword[@role eq 'Herausgeber']"/>
  <xsl:variable name="authors" as="element(dbk:keyword)*" 
                select="$metadata/dbk:keyword[@role eq 'Autor']"/>
  <xsl:variable name="author-info" as="element(dbk:keyword)*"
                select="$metadata/dbk:keyword[@role eq 'Autoreninformationen']" />
  <!-- title metadata -->
  <xsl:variable name="title" 
                select="($metadata/dbk:keyword[@role eq 'Titel'][not(. = 'Fallback')], /dbk:hub/dbk:info/dbk:title)[1]" as="element(*)?"/>
  <xsl:variable name="subtitle" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Untertitel']"/>
  <xsl:variable name="shorttitle" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Kurztitel']"/>
  <!-- cover image -->
  <xsl:variable name="cover-href" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Cover']"/>
  <!-- series metadata -->
  <xsl:variable name="series-number" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihennummer']"/>
  <xsl:variable name="series-name"  as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihe']"/>
  <xsl:variable name="subseries-name"  as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Reihenuntertitel']"/>
  <xsl:variable name="volume" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Bandnummer']"/>
  <!-- publisher -->
  <xsl:variable name="publisher-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsname']"/>
  <xsl:variable name="publisher-imprint-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsimprint']"/>
  <xsl:variable name="publisher-imprint-info" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsinfo']"/>
  <xsl:variable name="publisher-logo-href" as="xs:string?" 
                select="replace($metadata/dbk:keyword[@role eq 'Reihenlogo'], '^.+/(.+)\.EPS$', 'logos/series/$1.png')"/>
  <xsl:variable name="publisher-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagshinweis']"/>
  <xsl:variable name="publisher-location" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Verlagsort']"/>
  <xsl:variable name="publisher-website" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'transcript-Website']"/>
  <!-- publication meta -->
  <xsl:variable name="doi" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'DOI']"/>
  <xsl:variable name="print-isbn" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Print-ISBN']"/>
  <xsl:variable name="epdf-isbn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'PDF-ISBN']"/>
  <xsl:variable name="epub-isbn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ePUB-ISBN']"/>
  <xsl:variable name="isbn-text" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ISBN-Text']"/>
  <xsl:variable name="issn" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'ISSN']"/>
  <xsl:variable name="dedication" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Widmung']"/>
  <xsl:variable name="acknowledgements" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Dank']"/>
  <xsl:variable name="editorial" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Editorial']"/>
  <xsl:variable name="edition-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Edition-Note']"/>
  <xsl:variable name="pub-year" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Jahr']"/>
  <xsl:variable name="statement" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Qualifikationsnachweis']"/>
  <xsl:variable name="biblio-info" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Bibliografische_Information']"/>
  <xsl:variable name="print-note" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Druckhinweis']"/>
  <xsl:variable name="environmental-note" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Umweltschutzhinweis']"/>
  <!-- Contributor Meta -->
  <xsl:variable name="lectorate" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lektorat']"/>
  <xsl:variable name="translator" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Ubersetzer']"/>
  <xsl:variable name="typesetter" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Satz']"/>
  <xsl:variable name="printer" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Druck']"/>
  <xsl:variable name="cover-credit" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Umschlagcredit']"/>
  <xsl:variable name="cover-art" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Umschlaggestaltung']"/>
  <xsl:variable name="copy-editing" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Korrektorat']"/>
  <xsl:variable name="converter" as="element(dbk:keyword)?" 
                select="$metadata/dbk:keyword[@role eq 'Konvertierung']"/>
  <!-- Licencing meta -->
  <xsl:variable name="copyright-note" as="xs:string?"
                select="$metadata/dbk:keyword[@role eq 'Copyright-Hinweis']/dbk:phrase[1]"/>
  <xsl:variable name="copyright-holder" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Copyright-Hinweis']/dbk:phrase[2]"/>
  <xsl:variable name="license-logo-href" as="xs:string?" 
                select="concat('http://this.transpect.io/', $metadata/dbk:keyword[@role eq 'Lizenzlogo'])"/>
  <xsl:variable name="license-text" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenztext']"/>
  <xsl:variable name="license-link" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenzlink']"/>
  <xsl:variable name="license-name" as="element(dbk:keyword)?"
                select="$metadata/dbk:keyword[@role eq 'Lizenz']"/>
  <!-- funding statement -->
  <xsl:variable name="funder-name" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Fordername']"/>
  <xsl:variable name="funder-logo" as="xs:string*" 
                select="tokenize($metadata/dbk:keyword[@role eq 'Forderlogos'], '\p{Zs}+')"/>
  <xsl:variable name="funder-pretext" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Fordertext']"/>
  <xsl:variable name="funder-posttext" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Fordertextpost']"/>
  
  <xsl:variable name="new-common"                 select="true()" as="xs:boolean"/>
  <xsl:variable name="create-customer-toctitles"  select="true()" as="xs:boolean"/>

  <ns prefix="dc" uri="http://purl.org/dc/elements/1.1/"/>
  <ns prefix="rdf" uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>
  
  <import href="../../common/xml2tex/latex.conf.xml"/>  
  
  <preamble>%
    % by transcript publishers
    %
    <xsl:value-of select="concat('\documentclass[',
                                 string-join(($babel-langs[position() ne 1],
                                              $babel-langs[1]), (: 1st lang is main lang and comes last :)
                                 ','),
                                 if($is-collection) then ',pubtype=collection' else (),
                                 if($notes-per-chapter = ('yes', 'true') or $notes-type = 'footnotes') then ',resetnotesperchapter' else (),
                                 if($notes-type eq 'endnotes' and $endnotes-with-chapter eq 'yes')  
                                                                     then ',endnoteswithchapters'
                                 else if($notes-type eq 'endnotes') 
                                                                     then ',endnotes' 
                                 else (),
                                 if($notes-type eq 'endnotes' and $notes-per-chapter-notoc eq 'yes') then ',ennotoc' else (),
                                 xml2tex:foreign-scripts(root()),
                                 ']{transpect}&#xa;')"/>
    \definecolor{color-1}{rgb}{0,0,0}
    \definecolor{color-2}{rgb}{0.85,0.85,0.85}
    <xsl:for-each select="xml2tex:rgb-to-tex-color( $colors )">
      <xsl:if test="not(matches(., 'color-(1|2)'))">        
        <xsl:value-of select="concat('\define', ., '&#xa;')"/>
      </xsl:if>
    </xsl:for-each>
    <xsl:value-of select="concat('\usepackage[lay=',
                                 lower-case($layout),
                                 ']{transcript}&#xa;')"/>
    
    <xsl:if test="$langs = 'zh'">
      <xsl:value-of select="'\usepackage{CJK}&#xa;'"/>
    </xsl:if>    
    <xsl:if test="$title-pages eq 'yes'">
      <xsl:text>&#xa;\begin{tpMeta}&#xa;</xsl:text>
        <!-- authors -->
        <xsl:for-each select="$authors">
          <xsl:text>&#xa;\begin{tpAuthor}</xsl:text>
          <xsl:value-of select="concat('&#xa;\tpFullName{', ., '}')"/>
          <xsl:if test="$author-info">
            <xsl:value-of select="concat('&#xa;\tpBio{', normalize-space($author-info), '}&#xa;')"/>
          </xsl:if>
          <xsl:text>\end{tpAuthor}&#xa;</xsl:text>
        </xsl:for-each>
      <xsl:for-each select="$editors">
        <xsl:text>&#xa;\begin{tpEditor}</xsl:text>
        <xsl:value-of select="concat('&#xa;\tpFullName{', ., '}')"/>
        <xsl:text>\end{tpEditor}&#xa;</xsl:text>
      </xsl:for-each>
      <xsl:if test="$title">
        <xsl:value-of select="concat('&#xa;\tpTitle{', $title, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$subtitle">
        <xsl:value-of select="concat('&#xa;\tpSubtitle{', $subtitle, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$shorttitle">
        <xsl:value-of select="concat('&#xa;\tpShortTitle{', $shorttitle, '}&#xa;')"/>
      </xsl:if>
      <!-- cover image -->
      <xsl:if test="$cover-href">
        <xsl:value-of select="concat('&#xa;\tpCover{', $cover-href, '}&#xa;')"/>
      </xsl:if>
      <!-- series metadata -->
      <xsl:if test="$series-number">
        <xsl:value-of select="concat('&#xa;\tpNumber{', $series-number, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$series-name">
        <xsl:value-of select="concat('&#xa;\tpSeries{', $series-name, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$subseries-name">
        <xsl:value-of select="concat('&#xa;\tpSubSeries{', $subseries-name, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$volume">
        <xsl:value-of select="concat('&#xa;\tpVolume{', $volume, '}&#xa;')"/>
      </xsl:if>
      <!-- publisher metadata -->
      <xsl:if test="$publisher-name">
        <xsl:value-of select="concat('&#xa;\tpPublisher{', $publisher-name, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-imprint-name">
        <xsl:value-of select="concat('&#xa;\tpPubDivision{', $publisher-imprint-name, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-imprint-info">
        <xsl:value-of select="concat('&#xa;\tpPubDivInfo{', $publisher-imprint-info, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-logo-href">
        <xsl:value-of select="concat('&#xa;\tpPubLogo{', $publisher-logo-href, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-note">
        <xsl:value-of select="concat('&#xa;\tpPubNote{', $publisher-note, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-location">
        <xsl:value-of select="concat('&#xa;\tpPubPlace{', $publisher-location, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$publisher-website">
        <xsl:value-of select="concat('&#xa;\tpPubWeb{', $publisher-website, '}&#xa;')"/>
      </xsl:if>
      <!-- publication meta -->
      <xsl:if test="$doi">
        <xsl:value-of select="concat('&#xa;\tpDOI{', $doi, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$print-isbn">
        <xsl:value-of select="concat('&#xa;\tpISBN{', $print-isbn, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$epdf-isbn">
        <xsl:value-of select="concat('&#xa;\tpEISBN{', $epdf-isbn, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$epub-isbn">
        <xsl:value-of select="concat('&#xa;\tpEpubISBN{', $epub-isbn, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$isbn-text">
        <xsl:value-of select="concat('&#xa;\tpEpubPreText{', $isbn-text, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$issn">
        <xsl:value-of select="concat('&#xa;\tpISSN{', $issn, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$dedication">
        <xsl:value-of select="concat('&#xa;\tpDedication{', $dedication, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$acknowledgements">
        <xsl:value-of select="concat('&#xa;\tpAcknowledgements{', $acknowledgements, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$editorial">
        <xsl:value-of select="concat('&#xa;\tpDedication{', $editorial, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$edition-note">
        <xsl:value-of select="concat('&#xa;\tpEditionNote{', $edition-note, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$pub-year">
        <xsl:value-of select="concat('&#xa;\tpYear{', $pub-year, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$statement">
        <xsl:value-of select="concat('&#xa;\tpStatement{', $statement, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$biblio-info">
        <xsl:value-of select="concat('&#xa;\tpBiblio{', $biblio-info, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$print-note">
        <xsl:value-of select="concat('&#xa;\tpPrintNote{', $print-note, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$environmental-note">
        <xsl:value-of select="concat('&#xa;\tpEnvDisclaimer{', $environmental-note, '}&#xa;')"/>
      </xsl:if>
      <!-- contributor meta -->
      <xsl:if test="$lectorate">
        <xsl:value-of select="concat('&#xa;\tpLectorate{', $lectorate, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$translator">
        <xsl:value-of select="concat('&#xa;\tpTranslator{', $translator, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$copy-editing">
        <xsl:value-of select="concat('&#xa;\tpQA{', $copy-editing, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$cover-credit">
        <xsl:value-of select="concat('&#xa;\tpCoverDesign{', $cover-credit, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$cover-art">
        <xsl:value-of select="concat('&#xa;\tpCoverImage{', $cover-art, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$typesetter">
        <xsl:value-of select="concat('&#xa;\tpTypesetter{', $typesetter, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$printer">
        <xsl:value-of select="concat('&#xa;\tpPrint{', $printer, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$converter">
        <xsl:value-of select="concat('&#xa;\tpConversion{', $converter, '}&#xa;')"/>
      </xsl:if>
      <!-- licensing meta -->
      <xsl:if test="$copyright-note">
        <xsl:value-of select="concat('&#xa;\tpCopyrightDisclaimer{', $copyright-note, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$copyright-holder">
        <xsl:value-of select="concat('&#xa;\tpCopyright{', tokenize($copyright-holder, ',')[2], '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$license-logo-href">
        <xsl:value-of select="concat('&#xa;\tpLicenceLogo{', $license-logo-href, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$license-text">
        <xsl:value-of select="concat('&#xa;\tpLicenceText{', $license-text, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$license-link">
        <xsl:value-of select="concat('&#xa;\tpLicenceLink{', $license-link, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$license-name">
        <xsl:value-of select="concat('&#xa;\tpLicenceName{', $license-name, '}&#xa;')"/>
      </xsl:if>
      <!-- funding statement -->
      <xsl:if test="$funder-name">
        <xsl:value-of select="concat('&#xa;\tpFundName{', $funder-name, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$funder-logo">
        <xsl:value-of select="concat('&#xa;\tpFundLogo{', $funder-logo, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$funder-pretext">
        <xsl:value-of select="concat('&#xa;\tpFundingPreText{', $funder-pretext, '}&#xa;')"/>
      </xsl:if>
      <xsl:if test="$funder-posttext">
        <xsl:value-of select="concat('&#xa;\tpFundingPostText{', $funder-posttext, '}&#xa;')"/>
      </xsl:if>
      <xsl:text>&#xa;\end{tpMeta}&#xa;</xsl:text>
    </xsl:if>
    <xsl:text>&#xa;\end{tpMeta}&#xa;</xsl:text>
    <xsl:for-each select="//dbk:index">
      <xsl:variable name="index-index" as="attribute(remap)" select="@remap"/>
      <xsl:value-of select="concat('\newindex{', $index-index, '}{', $index-index, '_idx}{', $index-index, '_ind}{}&#xa;')"/>
    </xsl:for-each>
  </preamble>
  
  <front>
    <xsl:if test="$title-pages eq 'yes'">
      <xsl:text>\tpMaketitle&#xa;</xsl:text>
    </xsl:if>
    <xsl:value-of select="'\setcounter{secnumdepth}{-1}&#xa;'"/>
    <xsl:value-of select="concat('\setcounter{tocdepth}{', 
                                   if(//dbk:part) 
                                   then xs:string(xs:integer($toc-depth) - 2)
                                   else xs:string(xs:integer($toc-depth) - 1),
                                   '}&#xa;')"/>
    <xsl:text>\tableofcontents&#xa;</xsl:text>
  </front>
  
    <template context="dbk:para[matches(@role, $endnotes-heading-style)]">
    <xsl:value-of select="concat('&#xa;\def\notesname{', . ,'}')"/>
    <xsl:text>&#xa;\printnotes&#xa;</xsl:text>
  </template>
  
  <template context="dbk:chapter[$notes-type eq 'endnotes' and $notes-per-chapter eq 'yes']
                                [.//dbk:footnote]
                                [not(.//dbk:para[matches(@role, $endnotes-heading-style)])]">

    <xsl:next-match/>

    <rule name="heading" type="env" break-after="2" break-before="1">
      <param select="'section'"/>
      <xsl:value-of select="concat('&#xa;\tpTitle{', 
                                 ('Anmerkungen', 'Notes', 'Notes')[index-of(('de', 'en', 'fr'), $main-lang)] ,
                                 '}')"/>
    </rule>
    <xsl:text>&#xa;\printnotes&#xa;</xsl:text>
    
  </template>
  
  <!--<template context="dbk:dedication[@role eq 'tsded']">
    <rule name="wid" type="env"  break-after="1" break-before="1">
      <param/>
    </rule>
  </template>-->
  
    <!--<template context="dbk:abbrev[matches(@role, $col-head-right-style)]">
    <rule name="chaptermark" type="cmd" break-after="1">
      <param/>
    </rule>
  </template>
  
  <template context="dbk:abbrev[matches(@role, concat($col-head-short-style, '|', $col-head-left-style))]">    
    <rule name="def\partmarkoverride" type="cmd" break-after="1" break-before="1">
      <param/>
    </rule>
  </template>-->
  
    <!-- suppress additional underline markup in titles -->
  
  <template context="dbk:part/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:chapter/dbk:info/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:section/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]
                    |dbk:bibliography/dbk:title/dbk:phrase[matches(@role, '^[a-z]{2,3}underline$')]">
    <rule>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:bibliography[not(@role eq 'Citavi')]/dbk:bibliodiv">
    <xsl:variable name="level" select="count(ancestor::dbk:bibliography)" as="xs:integer"/>
    <xsl:variable name="name" as="xs:string"
                  select="if($level eq 1) then 'section'
                     else if($level eq 2) then 'subsection'
                     else if($level eq 3) then 'subsubsection'
                     else                      'paragraph'"/>
    <xsl:value-of select="concat('\def\bibname{', dbk:title, '}&#xa;', 
                                 '\renewcommand\bibsection{\', $name, '*{\bibname}}&#xa;')"/>
    <rule name="bibsection" type="env">
      <text/>
    </rule>
  </template>
   
  <!-- headings -->
  <!--<template context="dbk:part/dbk:info | dbk:section/dbk:info | dbk:chapter/dbk:info | dbk:preface/dbk:info | dbk:appendix/dbk:info | dbk:bibliogaphy/dbk:info">
    <xsl:apply-templates select="node()" mode="#current"/>
  </template>-->

  <!--<xsl:template name="option-for-headlines">
    <xsl:if test=".//dbk:footnote
                 |parent::*/dbk:subtitle
                 |parent::*/dbk:info/dbk:subtitle">
      <xsl:text>[</xsl:text>
      <xsl:apply-templates select="node()" mode="#current">
        <xsl:with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
      </xsl:apply-templates>
      <xsl:text>]</xsl:text>
    </xsl:if>
  </xsl:template>-->

  <!--<template context="dbk:title[matches(@role, $genereral-heading-style)]/dbk:phrase[@role eq 'hub:identifier']"/>-->

  <!--<template context="dbk:title[matches(@role, '^[a-z]{2,3}heading(enumerated)?1$')]">
    <xsl:choose>
      <xsl:when test="dbk:phrase[@role eq 'hub:identifier']">
        <xsl:value-of select="concat('\setcounter{secnumdepth}{', $secnumdepth, '}&#xa;')"/>
        <xsl:value-of select="string-join(('\def\thechapter{', dbk:phrase[@role eq 'hub:identifier'], '}&#xa;'), '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\setcounter{secnumdepth}{-2}</xsl:text>    
      </xsl:otherwise>
    </xsl:choose>
    <rule name="chapter" type="cmd" break-after="2" break-before="2">
      <xsl:call-template name="option-for-headlines"/>
      <param/>
    </rule>
    <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->
    
  <!--<template context="dbk:title[matches(@role, '^[a-z]{2,3}heading(enumerated)?2$')]">
    <xsl:choose>
      <xsl:when test="dbk:phrase[@role eq 'hub:identifier']">
        <xsl:value-of select="concat('\setcounter{secnumdepth}{', $secnumdepth, '}&#xa;')"/>
        <xsl:value-of select="string-join(('\def\thesection{', dbk:phrase[@role eq 'hub:identifier'], '}&#xa;'), '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\setcounter{secnumdepth}{-1}</xsl:text>    
      </xsl:otherwise>
    </xsl:choose>
    <rule name="section" type="cmd" break-after="2" break-before="2">
      <xsl:call-template name="option-for-headlines"/>
      <param/>
    </rule>
    <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->
  
  <!--<template context="dbk:title[matches(@role, '^[a-z]{2,3}heading(enumerated)?3$')]">
    <xsl:choose>
      <xsl:when test="dbk:phrase[@role eq 'hub:identifier']">
        <xsl:value-of select="concat('\setcounter{secnumdepth}{', $secnumdepth, '}&#xa;')"/>
        <xsl:value-of select="string-join(('\def\thesubsection{', dbk:phrase[@role eq 'hub:identifier'], '}&#xa;'), '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\setcounter{secnumdepth}{0}</xsl:text>    
      </xsl:otherwise>
    </xsl:choose>
    <rule name="subsection" type="cmd" break-after="2" break-before="2">
      <xsl:call-template name="option-for-headlines"/>
      <param/>
    </rule>
    <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->
  
  <!--<template context="dbk:title[matches(@role, '^[a-z]{2,3}heading(enumerated)?4$')]">
    <xsl:choose>
      <xsl:when test="dbk:phrase[@role eq 'hub:identifier']">
        <xsl:value-of select="concat('\setcounter{secnumdepth}{', $secnumdepth, '}&#xa;')"/>
        <xsl:value-of select="string-join(('\def\thesubsubsection{', dbk:phrase[@role eq 'hub:identifier'], '}&#xa;'), '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\setcounter{secnumdepth}{1}</xsl:text>    
      </xsl:otherwise>
    </xsl:choose>
    <rule name="subsubsection" type="cmd" break-after="2" break-before="2">
      <xsl:call-template name="option-for-headlines"/>
      <param/>
    </rule>
    <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->
  
  <!--<template context="dbk:title[matches(@role, '^[a-z]{2,3}heading(enumerated)?5$')]">
    <xsl:choose>
      <xsl:when test="dbk:phrase[@role eq 'hub:identifier']">
        <xsl:value-of select="concat('\setcounter{secnumdepth}{', $secnumdepth, '}&#xa;')"/>
        <xsl:value-of select="concat('\def\theparagraph{', dbk:phrase[@role eq 'hub:identifier'], '}&#xa;')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\setcounter{secnumdepth}{2}</xsl:text>    
      </xsl:otherwise>
    </xsl:choose>
    <rule name="paragraph" type="cmd" break-after="2" break-before="2">
      <param/>
    </rule>
    <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->

  <!--<template context="dbk:preface/dbk:title
                    |dbk:preface/dbk:info/dbk:title">
    <rule name="chapter*" type="cmd"  break-after="2" break-before="2">
      <xsl:call-template name="option-for-headlines"/>
      <param/>
      <text select="concat('\addcontentsline{toc}{chapter}{', ., '}')"/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:dedication">
    <rule name="widmung" type="env"  break-after="1" break-before="1">
      <param/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:dedication//dbk:br">
    <xsl:text>\\</xsl:text>
  </template>-->
  
  <!--<template context="dbk:part/dbk:title
                    |dbk:part/dbk:info/dbk:title">
      <rule name="part" type="cmd" break-after="2" break-before="2">
        <xsl:text>{</xsl:text>
        <xsl:if test="dbk:phrase[@role eq 'hub:identifier']">
          <xsl:value-of select="concat('\protect\numberline{', dbk:phrase[@role eq 'hub:identifier'] ,'&#x20;}')"/>
        </xsl:if>
        <xsl:apply-templates mode="#current"/>
        <xsl:text>}</xsl:text>
      </rule>
      <xsl:apply-templates select=".//dbk:anchor" mode="#current"/>
  </template>-->
  
  <template context="dbk:blockquote[dbk:para][not(matches(@role, '^[a-z]+_?verse.*$'))]
                    |dbk:blockquote[matches(@role, $dialogue-style)]">
    <rule name="quotation" type="env">
      <text/>
    </rule>
  </template>
  
  <template context="dbk:blockquote[not(matches(@role, '^[a-z]+_?verse.*$'))]
                                   [count(dbk:para) gt 1]/dbk:para">
    <rule break-after="2">
      <text>\setlength{\parindent}{5mm}</text>
      <text/>
    </rule>
  </template>
  
 <template context="dbk:para[following-sibling::*[1][self::dbk:blockquote]]
                   |dbk:blockquote/dbk:para[last()]
                   |dbk:caption/dbk:para[last()]">
    <rule break-after="0">
      <text/>
    </rule>
    <!-- copied from common to reinstall template priorities-->
  </template>
  
  <!--<template context="dbk:table">
    <rule name="transcriptTab" type="cmd" break-after="2" break-before="1">
      <param select="dbk:title, 
                     dbk:caption"/>  
      <param select="dbk:tgroup"/>
    </rule>
  </template>-->
  
  <!-- copied from ../a9s/common/xml2tex/latex.conf.xml -->
  
  <!--<template context="*[local-name() = ('table', 'informaltable')]
                      [   matches(@role, $rotated-table-style)
                       or exists(.//dbk:entry[   matches(@css:transform, 'rotate\((90|270)deg\)')
                                 or @css:writing-mode eq 'bt-lr']
                                 )]">
    <rule name="sidewaystable" type="env">
      <param select="dbk:title, 
                     dbk:caption"/>
      <param select="dbk:tgroup"/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:figure">
    <rule name="transcriptBild" type="cmd" break-after="1" break-before="1">
      <param select="dbk:title, 
                     dbk:caption"/>
      <param select="dbk:mediaobject"/>
    </rule>
  </template>-->

  <!--<template context="dbk:figure[matches(@role, $fig-style)]">
    <rule name="figure" type="env" break-after="1" break-before="1">
      <option>h!</option>
      <text>&#xa;\transcriptFixedFigure</text>
      <param select="dbk:title, 
                     dbk:caption"/>
      <param select="replace(@role, '^[a-z]{2,3}figure([A-Z])(\d)$', '$1')"/>
      <xsl:text>{%</xsl:text>
        <xsl:for-each select="dbk:mediaobject">
          <xsl:text>&#xa;</xsl:text>
          <xsl:apply-templates mode="#current"/>
        </xsl:for-each>
      <xsl:text>}</xsl:text>
    </rule>
  </template>-->

  <!--<template context="dbk:figure/dbk:title|dbk:table/dbk:title">
    <rule break-after="1" break-before="1" name="caption" type="cmd">
      <param/>
    </rule>
  <!-\- copied from docx2tex/conf for compatibility reasons-\->
  </template>-->
  
  <!--<template context="dbk:figure/dbk:title[not(matches(., '^[\S\r\n]+$'))]
                    |dbk:table/dbk:title[not(matches(., '^[\S\r\n]+$'))]">
    <rule name="caption" type="cmd">
      <xsl:if test=".//dbk:footnote
                   |.//dbk:link">
        <xsl:text>[</xsl:text>
        <xsl:apply-templates mode="figure-titles"/>
        <xsl:text>]</xsl:text>
      </xsl:if>
      <param/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:imagedata[@fileref]">
    <rule name="includegraphics" type="cmd">
      <option select="concat('width=', 
                             1 div count(ancestor::*[dbk:mediaobject
                                                    |dbk:inlinemediaobject]/*[local-name() = ('mediaobject', 
                                                                                              'inlinemediaobject')]),'\textwidth')"/>
      <param select="replace(@fileref, '^.+/(.+?)$', concat($image-dir, '$1'))"/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:figure[matches(@role, $fig-style)]//dbk:imagedata">
    <rule name="includesubgraphics" type="cmd">
      <param/>
      <param select="replace(@fileref, '^.+/(.+?)$', concat($image-dir, '$1'))"/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:figure/dbk:caption
                    |dbk:table/dbk:caption">
    <rule name="capsource" type="cmd">
      <param/>
    </rule>
  </template>-->
  
  <!--<template context="/dbk:hub/*[self::dbk:part | self::dbk:chapter | self::dbk:section][1]">
    <xsl:next-match/>
  </template>-->

  <!--<template context="dbk:section[count(ancestor::dbk:section) eq 0]/dbk:subtitle
                    |dbk:section[count(ancestor::dbk:section) eq 0]/dbk:info/dbk:subtitle">
    <rule name="subheading" type="cmd" break-after="2" break-before="2">
      <param/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:section[count(ancestor::dbk:section) gt 0]/dbk:subtitle
                    |dbk:section[count(ancestor::dbk:section) gt 0]/dbk:info/dbk:subtitle">
    <rule name="subsubheading" type="cmd" break-after="2" break-before="2">
      <param/>
    </rule>
  </template>-->

  <template context="*[not(local-name() = ('part', 'chapter', 'section'))][@css:page-break-before='always']">
    <xsl:text>\pagebreak&#xa;</xsl:text>
    <xsl:next-match/>
  </template>

  <template context="dbk:para[dbk:personname[@role eq 'speaker']]">
    <rule name="item" type="cmd" break-before="1">
      <option select="dbk:personname[@role eq 'speaker']/normalize-space(string-join(node(), ''))"/>
      <text select="node() except dbk:personname[@role eq 'speaker']"/>
    </rule>
  </template>
  
  <!-- https://redmine.le-tex.de/issues/9852 -->
  
  <xsl:variable name="list-mark-map" as="element(xml2tex:map)+">
    <xml2tex:map from="dash"   to="&#x2014;"/>
    <xml2tex:map from="bullet" to="&#x2022;"/>
    <xml2tex:map from="circle" to="&#x25cb;"/>
    <xml2tex:map from="square" to="&#x25aa;"/>
  </xsl:variable>

  <template context="dbk:itemizedlist[@mark]/dbk:listitem">
    <rule name="item" type="cmd">
      <option select="if(matches(parent::*/@mark, string-join($list-mark-map/@from, '|')))
                      then for $mark in parent::*/@mark
                           return $list-mark-map[@from eq $mark]/@to
                      else parent::*/@mark"/>
      <text select="' '"/>
      <text/>
    </rule>
  </template>
  
  <!--<template context="*[self::dbk:chapter | self::dbk:section | self::dbk:part | self::dbk:appendix][dbk:info[dbk:title[matches(@role, $list-of-figures-style)]]]">
    <xsl:apply-templates select="dbk:info" mode="#current"/>
    <rule name="listoffigures" type="cmd" break-after="1"/>
  </template>
  
  
   <template context="*[self::dbk:chapter 
                       |self::dbk:section 
                       |self::dbk:part
                       |self::dbk:appendix]
                       [dbk:info[dbk:title[matches(@role, $list-of-figures-style)]]]">
    <rule>
      <text/>
    </rule>
  </template>
  
  <template context="*[self::dbk:chapter 
                      |self::dbk:section 
                      |self::dbk:part
                      |self::dbk:appendix]
                      [dbk:info[dbk:title[matches(@role, $list-of-tables-style)]]]">
    <rule>
      <text/>
    </rule>
  </template>-->
  
  <!--<template context="dbk:para[matches(@role, $list-of-figures-style)]
                    |dbk:title[matches(@role, $list-of-figures-style)]">
    <rule name="renewcommand" type="cmd" break-after="1" break-before="1">
      <param>\listfigurename</param>
      <param/>
    </rule>
    <rule name="listoffigures" type="cmd" break-after="1"/>
  </template>
  
  <template context="dbk:para[matches(@role, $list-of-tables-style)]
                    |dbk:title[matches(@role, $list-of-tables-style)]">
    <rule name="renewcommand" type="cmd" break-after="1" break-before="1">
      <param>\listtablename</param>
      <param/>
    </rule>
    <rule name="listoftables" type="cmd" break-after="1"/>
  </template>-->
  
  <template context="dbk:para[matches(@role, 'tsmedia(caption|url|source)')]" priority="300"/>
  
  <template context="dbk:link[@xlink:href][matches(@xlink:href, '^(https?|ftp):') or matches(., '^(https?|ftp):')]">
    <rule name="href" type="cmd">
      <param select="replace((@url, @xlink:href)[1], '(%|#|_|\\)', '\\$1' )"/>
      <param select="xml2tex:add-tactical-break-chars-in-linktext(.)"/>
    </rule>
  </template>
  
  <!--<template context="dbk:info/dbk:epigraph[@role eq 'motto']">
    <rule name="quote" type="cmd" break-before="1">
      <xsl:text>{</xsl:text>
      <xsl:apply-templates select="dbk:*[not(matches(@role, $motto-source-style))]" mode="#current"/>
      <xsl:text>}</xsl:text>
    </rule>
    <rule name="quotesource" type="cmd" break-before="1">
      <param/>
    </rule>
  </template>-->
  
  <template context="dbk:title[matches(@role, $general-heading-style)]/dbk:tab[preceding-sibling::dbk:phrase[@role eq 'hub:identifier']]"/>

  <xsl:variable name="col-author-style" select="'^[a-z]{1,3}headline(author)$'" as="xs:string"/>

  <template name="col-titles">
    <!-- use col-style para for runtitle. if it doesn't exist and heading contains footnotes or linebreaks:
         discard those and use as column title. otherwise do not create an element-->

<!--    <xsl:choose>
      <xsl:when test="$is-collection">-->
<!--        links: tpAuthor/tpRunAuthor, wenn es den nicht gibt: \tp(Run)Title | Rechts: \tp(Run)Title-->
        <xsl:if test="dbk:abbrev[matches(@role, $col-author-style)] or dbk:author[descendant::*[self::dbk:footnote | self::dbk:br]]">
          <rule name="tpRunAuthor" type="cmd" break-before="1">
            <param select="(dbk:abbrev[matches(@role, $col-author-style)], 
                            dbk:author[descendant::*[self::dbk:footnote | self::dbk:br]]
                            )[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="dbk:abbrev[matches(@role, $col-head-style)] or dbk:title[descendant::*[self::dbk:footnote]]">
          <rule name="tpRunTitle" type="cmd" break-before="1">
            <param select="(dbk:abbrev[matches(@role, $col-head-style)] , dbk:title)[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="(dbk:title[descendant::*[self::dbk:footnote]]/dbk:phrase[@role = ('identifier', 'hub:identifier')] and not(dbk:abbrev[matches(@role, $col-head-style)]))
                      or 
                      dbk:abbrev[matches(@role, $col-head-style)]">
          <rule name="tpRunNumber" type="cmd" break-before="1">
            <param select="if (dbk:abbrev[matches(@role, $col-head-style)])
                           then dbk:abbrev[matches(@role, $col-head-style)]/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()
                           else dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
<!--      </xsl:when>-->
      <!--<xsl:otherwise>
       MONO: links: tsheadlineleft bzw. Titel des Buches.  | rechts Kapitel√ºberschrift 1 oder ts_headline_right. (= tpRunTitle)
        <xsl:if test="dbk:abbrev[matches(@role, $col-head-right-style)] or dbk:author[descendant::*[self::dbk:footnote | self::dbk:br]]">
          <rule name="tpRunAuthor" type="cmd" break-before="1">
            <param select="(dbk:abbrev[matches(@role, $col-head-left-style)], dbk:author[descendant::*[self::dbk:footnote | self::dbk:br]])[1]/node()
              [not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="dbk:abbrev[matches(@role, $col-head-right-style)] or dbk:title[descendant::*[self::dbk:footnote]]">
          <rule name="tpRunTitle" type="cmd" break-before="1">
            <param select="dbk:title/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
        <xsl:if test="(dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')] and not(dbk:abbrev[matches(@role, $col-head-left-style)]))
                      or 
                      dbk:abbrev[matches(@role, $col-head-left-style)][dbk:phrase[@role = ('identifier', 'hub:identifier')]]">
          <rule name="tpRunNumber" type="cmd" break-before="1">
            <param select="(dbk:abbrev[matches(@role, $col-head-left-style)]/dbk:phrase[@role = ('identifier', 'hub:identifier')],
                            dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')])[1]/node()">
              <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
              <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
            </param>
          </rule>
        </xsl:if>
      </xsl:otherwise>-->
<!--    </xsl:choose>-->

    <xsl:if test="dbk:subtitle[descendant::*[self::dbk:footnote | self::dbk:br]]">
      <rule name="tpRunSubtitle" type="cmd" break-before="1">
        <param select="dbk:subtitle/node()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
  </template>

</set>
