<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<set xmlns="http://transpect.io/xml2tex" 
     xmlns:xml2tex="http://transpect.io/xml2tex" 
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  
  <import href="../../xml2tex/latex.conf.xml"/>

  <xsl:param name="cocotex" as="xs:boolean" select="true()"/>
  <xsl:param name="s9y2" as="xs:string?"><!-- journal series type like zig--></xsl:param>
  <xsl:variable name="aff-as-ref" as="xs:boolean" select="false()"/>
  
  <xsl:variable name="title" as="element(*)?"
                select="$metadata/dbk:keyword[@role = ('Hefttitel')]" />
  <xsl:variable name="volume" as="item()*"
                select="($metadata/dbk:keyword[@role eq 'Bandnummer'][normalize-space()], replace(/dbk:hub/dbk:info/dbk:issuenum, '^(\d+)[/\p{Zs}-](\d+)$', '$1'))[1]"/>
  <xsl:variable name="issue" as="item()*"
                select="($metadata/dbk:keyword[@role eq 'Ausgabe'][normalize-space()], replace(/dbk:hub/dbk:info/dbk:issuenum, '^(\d+)[/\p{Zs}-](\d+)$', '$2'))[1]"/>
  <xsl:variable name="pub-year" as="item()*"
                select="($metadata/dbk:keyword[@role eq 'Jahr'][normalize-space()], /dbk:hub/dbk:info/dbk:pubdate)[1]"/>
  <xsl:variable name="journal-title" as="item()*"
                select="($metadata/dbk:keyword[@role eq 'Reihe'][normalize-space()], /dbk:hub/dbk:info/dbk:productname[@otherclass= 'journal-title'])[1]"/>
 <xsl:variable name="series-name"  as="element(dbk:keyword)?" select="()"/>
 <xsl:variable name="journal-name"  as="element(dbk:keyword)?" select="$metadata/dbk:keyword[@role eq 'Reihe']"/>
 <xsl:variable name="prices"  as="element(dbk:keyword)?" select="$metadata/dbk:keyword[@role eq 'Preise']"/>
 <xsl:variable name="memberlist"  as="element(dbk:keyword)?" select="$metadata/dbk:keyword[@role eq 'Reihenherausgeberliste']"/>
 <xsl:variable name="pub-cycle"  as="element(dbk:keyword)?" select="$metadata/dbk:keyword[@role eq 'Publikationsturnus']"/>

<!--  
  <preamble>%
    % transcript journal
    %
    <xsl:value-of select="concat('\documentclass[',
                                 string-join(($babel-langs[position() ne 1],
                                              $babel-langs[1]), (: 1st lang is main lang and comes last :)
                                 ','),
                                 ',article',
                                 ',lay=',
                                 lower-case($layout),
                                 xml2tex:foreign-scripts(root()),
                                 ']{transcript}&#xa;')"/>
    \definecolor{color-1}{rgb}{0,0,0}
    \definecolor{color-2}{rgb}{0.85,0.85,0.85}
    <xsl:for-each select="xml2tex:rgb-to-tex-color( $colors )">
      <xsl:if test="not(matches(., 'color-(1|2)'))">        
        <xsl:value-of select="concat('\define', ., '&#xa;')"/>
      </xsl:if>
    </xsl:for-each>
    <xsl:if test="$langs = 'zh'">
      <xsl:value-of select="'\usepackage{CJK}&#xa;'"/>
    </xsl:if>
  </preamble>-->
  
  <xsl:variable name="license-logo-href" as="xs:string?" 
                select="$metadata/dbk:keyword[@role eq 'Lizenzlogo']"/>
  <xsl:variable name="series-options" select="concat(',journal_series=',$s9y2)" as="xs:string"/>


  <front>
    <xsl:if test="$title-pages eq 'yes'">
      <xsl:text>\tpMaketitle&#xa;</xsl:text>
    </xsl:if>
    <xsl:value-of select="'\setcounter{secnumdepth}{-1}&#xa;'"/>
    <xsl:value-of select="concat('\setcounter{tocdepth}{', 
                                   if(//dbk:part) 
                                   then xs:string(xs:integer($toc-depth) - 2)
                                   else xs:string(xs:integer($toc-depth) - 1),
                                   '}&#xa;')"/>
    <xsl:text>\tableofcontents&#xa;</xsl:text>
  </front>
  
  <xsl:variable name="open-access" as="xs:boolean" 
                select="$metadata/dbk:keyword[@role eq 'Lizenztext'][normalize-space()][matches(.,'BY')]
                         or
                         (some $c in //dbk:chapter/dbk:info/dbk:biblioset/dbk:legalnotice satisfies matches($c, 'Creative\p{Zs}+Commons', 'i'))
                         or
                         $metadata/dbk:keyword[@role eq 'Lizenzlogo'][normalize-space()][matches(., 'by', 'i')]"/>

  
  <xsl:template name="xml2tex:add-publicationtype-specific-meta">
   <xsl:if test="not($license-name[normalize-space()](:already applied in main template then:)) 
                 and 
                 $open-access">
     <xsl:value-of select="concat('&#xa;\tpLicenceName{',
                                  replace((//dbk:chapter[dbk:info/dbk:biblioset/dbk:legalnotice[matches(., 'Creative\p{Zs}+Commons', 'i')]])[1]/
                                            dbk:info/dbk:biblioset/dbk:legalnotice[matches(., 'Creative\p{Zs}+Commons', 'i')][1], 
                                          '^.*(Creative\p{Zs}+Commons.+?\)).*$', '$1'),
                                  '}')"/>
    </xsl:if> 
   <xsl:sequence select="xml2tex:meta2tex($prices, (), 'tpPrices'),
                         xml2tex:meta2tex($pub-cycle, (), 'tpPubCycle'),
                         xml2tex:meta2tex($memberlist, (), 'tpMemberList')"/>
  </xsl:template>


  <xsl:template match="text()[ancestor::*[self::dbk:keyword[@role = 'Preise']]]" mode="xml2tex" priority="300">
    <!-- prevent filename replacement in keywords -->
    <xsl:variable name="content" select="replace( ., '&#xa0;', '~')" as="xs:string"/>
    <xsl:value-of select="$content"/>
  </xsl:template>

<!--  <template context="dbk:dedication[@role eq 'tsded']">
    <rule name="wid" type="env"  break-after="1" break-before="1">
      <param/>
    </rule>
  </template>
  
    <template context="dbk:abbrev[matches(@role, $col-head-right-style)]">
    <rule name="chaptermark" type="cmd" break-after="1">
      <param/>
    </rule>
  </template>
  
  <template context="dbk:abbrev[matches(@role, concat($col-head-short-style, '|', $col-head-left-style))]">    
    <rule name="def\partmarkoverride" type="cmd" break-after="1" break-before="1">
      <param/>
    </rule>
  </template>-->
  
  <template context="*[not(self::dbk:hub)]/dbk:info//*[self::dbk:author|self::dbk:editor]">

      <xsl:if test="not(@role = 'override')">
        <!-- if author contains only name â†’ tpAuthorNameList. If name is structured though or if other metadata is present generate environment -->
        <rule name="tpAuthor" type="env" break-after="0" break-before="1">
          <text select="node()">
            <with-param name="in-author" tunnel="yes" as="xs:boolean" select="true()"/>
          </text>
        </rule>
      </xsl:if>
      <xsl:if test="@role = 'override'">
        <xsl:choose>
          <xsl:when test="dbk:personname/dbk:othername/@role = 'tsreviewer'">
            <!-- reviewer is only created as \tpRunAuthorNameList (https://redmine.le-tex.de/issues/14887#note-17) to avoid displaying-->
            <rule name="tpRunAuthorNameList" type="cmd" break-before="1">
              <param select="if (exists(ancestor::dbk:info//dbk:titleabbrev[@role='tsheadlineauthor'])) 
                             then ancestor::dbk:info//dbk:titleabbrev[@role='tsheadlineauthor']
                             else for $a in dbk:personname/dbk:othername return normalize-space($a)"/>
            </rule>
          </xsl:when>
          <xsl:otherwise>
            <rule name="tpAuthorNameList" type="cmd" break-before="1">
              <param select="for $a in dbk:personname/dbk:othername return normalize-space($a)"/>
            </rule>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    
  </template>

  <template name="customer-toctitles">
    <rule name="tpTocTitle" type="cmd" break-after="0" break-before="1">
      <param select="dbk:title/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
        <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
        <with-param name="remove-newline" select="false()" as="xs:boolean" tunnel="yes"/>
        <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
      </param>
    </rule>
    <xsl:if test="dbk:title[dbk:phrase[@role = ('identifier', 'hub:identifier')]]">
      <rule name="tpTocNumber" type="cmd" break-after="0" break-before="1">
        <param select="dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')]/text()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="dbk:subtitle">
      <rule name="tpTocSubtitle" type="cmd" break-after="0" break-before="1">
        <param select="dbk:subtitle/node()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-newline" select="false()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="dbk:author or dbk:authorgroup/dbk:author">
      <rule name="tpTocAuthorNameList" type="cmd" break-after="0" break-before="1">
        <param select="if ((dbk:author|dbk:authorgroup/dbk:author)[@role = 'override']) 
                       then (dbk:author|dbk:authorgroup/dbk:author)[@role = 'override']/dbk:personname/dbk:othername/node()
                       else string-join((dbk:author|dbk:authorgroup/dbk:author)[not(@role = 'override')]/dbk:personname/dbk:othername/node(), '/')">
          <with-param name="remove-footnote" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="suppress-foreign-lang" select="true()" as="xs:boolean" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
  </template>

  <template name="col-titles">
    <!-- use col-style para for runtitle. if it doesn't exist and heading contains footnotes or linebreaks:
         discard those and use as column title. otherwise do not create an element-->

<!--    <xsl:choose>
      <xsl:when test="$is-collection">-->
<!--        links: tpAuthor/tpRunAuthorNameList, wenn es den nicht gibt: \tp(Run)Title | Rechts: \tp(Run)Title-->

    <xsl:if test="(dbk:titleabbrev[matches(@role, $col-author-style)] or .//*[self::dbk:author|self::dbk:editor][descendant::*[self::dbk:footnote | self::dbk:br]]) 
                  and not(.//*[self::dbk:author|self::dbk:editor][dbk:personname/dbk:othername/@role = 'tsreviewer'])">
      <rule name="tpRunAuthorNameList" type="cmd" break-before="1">
        <param select="(dbk:titleabbrev[matches(@role, $col-author-style)], 
          .//*[self::dbk:author|self::dbk:editor][descendant::*[self::dbk:footnote | self::dbk:br]]
          )[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="dbk:titleabbrev[matches(@role, $col-head-style)] 
      or  
      dbk:title[descendant::*[self::dbk:footnote | self::dbk:br]]">
      <rule name="tpRunTitle" type="cmd" break-before="1">
        <param select="(dbk:titleabbrev[matches(@role, $col-head-style)] , dbk:title)[1]/node()[not(self::dbk:phrase[@role = ('identifier', 'hub:identifier')])]">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    <xsl:if test="(dbk:title[descendant::*[self::dbk:footnote]]/dbk:phrase[@role = ('identifier', 'hub:identifier')] and not(dbk:titleabbrev[matches(@role, $col-head-style)]))
      or 
      dbk:titleabbrev[matches(@role, $col-head-style)][dbk:phrase[@role = ('identifier', 'hub:identifier')]]">
      <rule name="tpRunNumber" type="cmd" break-before="1">
        <param select="if (dbk:titleabbrev[matches(@role, $col-head-style)])
          then dbk:titleabbrev[matches(@role, $col-head-style)]/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()
          else dbk:title/dbk:phrase[@role = ('identifier', 'hub:identifier')]/node()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
    
    <xsl:if test="dbk:subtitle[descendant::*[self::dbk:footnote | self::dbk:br]]">
      <rule name="tpRunSubtitle" type="cmd" break-before="1">
        <param select="dbk:subtitle/node()">
          <with-param name="remove-footnote" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-newline" select="true()" as="xs:boolean?" tunnel="yes"/>
          <with-param name="remove-indexterm" select="true()" as="xs:boolean?" tunnel="yes"/>
        </param>
      </rule>
    </xsl:if>
  </template>

  <template name="create-bookmark-content">
    <xsl:if test="exists(*[not(self::dbk:footnote
                          |self::dbk:br
                          |self::dbk:phrase[@role = ('identifier', 'hub:identifier')]
                          |self::dbk:tab
                          |self::dbk:anchor)])
                  and 
                  exists(dbk:phrase[@role = ('identifier', 'hub:identifier')])">
      <!-- if title contains markup, create \tpBM-Makros. if \tpBMTitle is created, also a \tpNumber is generated. empty or -->
      <rule name="tpBMNumber" type="cmd" break-before="1">
        <xsl:variable name="content">
          <xsl:apply-templates select="dbk:phrase[@role = ('identifier', 'hub:identifier')]" mode="bookmark-contents"/>
        </xsl:variable>
        <param select="replace(string-join($content, ''), '\s+$', '')"/>
      </rule>
    </xsl:if>
    <xsl:if test="exists(*[not(self::dbk:footnote
                              |self::dbk:br
                              |self::dbk:phrase[@role = ('identifier', 'hub:identifier')]
                              |self::dbk:tab
                              |self::dbk:anchor)])
                  or 
                  matches(., '[&amp;&#x9;&#xa0;&#x2000;-&#x200a;]')">
      <rule name="tpBMTitle" type="cmd" break-before="1">
        <!-- Newlines in title items are discarded by default (remove-newline). 
             If they are preserved in your project remove '|self::dbk:br' from if-condition. 
             Special characters like ampersands are not displayed correctly in bookmarks 
             and therefore have to be escaped, https://redmine.le-tex.de/issues/11930 -->
        <xsl:variable name="content">
          <xsl:apply-templates select="node() except dbk:phrase[@role = ('identifier', 'hub:identifier')]" mode="bookmark-contents"/>
        </xsl:variable>
        <param select="replace(
                               replace(
                                       replace(string-join($content, ''), '\s+$', ''),
                                       '\\(&amp;)',
                                       '\\string$1'
                                       ),
                               '\p{Zs}',
                               '&#x20;'
                               )"/>
      </rule>
    </xsl:if>
    <xsl:if test="../*[self::dbk:author|self::dbk:authorgroup[dbk:author]]
                      [descendant::dbk:personname/dbk:othername/*[not(self::dbk:footnote
                                                         |self::dbk:br
                                                         |self::dbk:tab
                                                         |self::dbk:anchor)]]">
      <rule name="tpBMAuthorNameList" type="cmd" break-before="1">
          <xsl:variable name="content">
            <xsl:choose>
              <xsl:when test="exists((dbk:author|dbk:authorgroup/dbk:author)[@role = 'override'])">
                  <xsl:apply-templates select="(dbk:author|dbk:authorgroup/dbk:author)[@role = 'override']/dbk:personname/dbk:othername/node()" mode="bookmark-contents"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:sequence select="string-join((dbk:author|dbk:authorgroup/dbk:author)[not(@role = 'override')]/dbk:personname/dbk:othername/node(), '/')"/>
               </xsl:otherwise>
              </xsl:choose>
          </xsl:variable>
          <param select="replace(string-join($content, ''), '\s+$', '')"/>
        </rule>
    </xsl:if>
    <xsl:if test="../*[self::dbk:subtitle][*[not(self::dbk:footnote
                                                |self::dbk:br
                                                |self::dbk:tab
                                                |self::dbk:anchor)]]">
      <rule name="tpBMSubtitle" type="cmd" break-before="1">
          <xsl:variable name="content">
            <xsl:apply-templates select="../*[self::dbk:subtitle]" mode="bookmark-contents"/>
          </xsl:variable>
          <param select="replace(string-join($content, ''), '\s+$', '')"/>
        </rule>
    </xsl:if>
  </template>

  <template context="dbk:info/dbk:biblioset/dbk:biblioid[@role = 'tsmetachunkdoi']">
   <!-- tpDOITitle also available-->
    <rule name="tpDOI" type="cmd" break-before="1" break-after="0">
      <xsl:variable name="doi-content" as="xs:string*" select="if (matches(., 'http')) then . else concat('https://doi.org/', .)"/>
      <param select="$doi-content"/>
    </rule>
  </template>

  <xsl:function name="xml2tex:use-author" as="xs:boolean">
    <xsl:param name="author" as="element()"/>
    <xsl:param name="all-authors" as="element()+"/>
    <xsl:choose>
      <xsl:when test="count($authors = 1) or $author[@role = 'override']"><xsl:sequence select="true()"/></xsl:when>
      <xsl:when test="every $a in $all-authors satisfies not($a/@role = 'override')"><xsl:sequence select="true()"/></xsl:when>
      <xsl:otherwise><xsl:sequence select="false()"/></xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <xsl:template match="dbk:info/dbk:biblioset" mode="xml2tex">
    <!--<xsl:apply-templates select="dbk:biblioid[@role = 'tsmetachunkdoi']" mode="#current"/>-->
        <xsl:apply-templates select="dbk:biblioid[@role = 'tsmetachunkdoi']" mode="xml2tex"/>
    <xsl:if test="dbk:legalnotice[normalize-space()]">
      <!-- several paras have to be merged to one makro -->
      <xsl:text>&#xa;\tpCopyright{</xsl:text>
      <xsl:for-each select="dbk:legalnotice[normalize-space()]">
        <xsl:apply-templates select="node()" mode="#current"/>
        <xsl:if test="not(. is ../dbk:legalnotice[last()])"><xsl:text>\tpBreak </xsl:text></xsl:if>
      </xsl:for-each>
      <xsl:text>}</xsl:text>
    </xsl:if>
    <xsl:if test="dbk:legalnotice[normalize-space()][matches(., 'BY')] or $open-access">
      <xsl:value-of select="'&#xa;\tpLicenceLogo{logos/oasymbol.pdf}'"/>
    </xsl:if>
  </xsl:template>



</set>
